## 布隆过滤器(Bloom Filter)

要判断一个元素是不是在一个集合里，比较容易想到的方法是用数组，链表这样的数据结构把元素保存起来，然后依次比较来确定。
但是随着集合的变大，上面的这种方法就面临几个问题，首先比较的速度随着数据量的增加而变慢，其次存储集合的空间也越来越大。

在数据库索引层面，通常索引很大，不可能一次性读入内存中。一般是从磁盘读入一个根索引页面，然后开始查找某一个键，如果没有就开始读取下一个索引页查找（可能必须从磁盘读取每⼀个），然后才能确定键不存在

为了解决上面的问题，就引入了**布隆过滤器（Bloom Filter）**

### 布隆过滤器原理

举个例子：

有Hash1和Hash2两个哈希函数

```
Hash1 = n%3
Hash2 = n%8

```

然后我们创建一个名叫bitMap长度是20的位图

```
bitMap=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

```

这个时候，我们要将7，存入到这个集合中

```
n = 7

```

分别用Hash1和Hash2计算n哈希后的值

```
Hash1  ->  1
Hash2  ->  7

```

我们把bitMap对应的值置为1，从0开始

```
bitMap=[0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

```

这样下次我们来查找7在不在这个集合的时候就可以用Hash1和Hash2计算完以后在bitMap集合中查找对应位置是否都是1，如果都是1则一定在集合中。

如果再在集合中插入13 分别用Hash1和Hash2计算n哈希后的值

```
n = 13
Hash1  ->  1
Hash2  ->  5

```

我们把bitMap对应的值置为1，从0开始

```
bitMap=[0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

```

这个时候我们发现1被映射到了两次，但是并不影响我们在集合[7, 13]中快速找到7或者13

### 定义

布隆过滤器的原理就是当一个元素被加入到集合的时候，用K个Hash函数将元素映射到一个位图中的K个点，并且把这个点的值设置为1，在每次检索的时候我们看一下这个点是不是都是1就知道集合中有没有这个元素了。

但是当插入的数据量大幅提升的时候，甚至bitMap全部被置为1的时候问题就很严重了，误识率就非常高了，这个也是根据不同场景实现布隆过滤器所要考虑的问题。

尽管有这样的问题，但是仍然不能掩盖布隆过滤器的空间利用率和查询时间远超其他算法，插入数据和查询数据的时间复杂度都是O(k)。 上述例子中K 为2，即 2个Hash 函数


### 误判

布隆过滤器的一个缺陷：存在误判。

但是，如果布隆过滤器判断某个元素不在布隆过滤器中，那么这个值就一定不在布隆过滤器中。总结就是：

- 布隆过滤器说某个元素在，可能会被误判
- 布隆过滤器说某个元素不在，那么一定不在
- 用英文说就是：False is always false. True is maybe true。  **没有你对我很重要**

### 误判率

布隆过滤器可以插入元素，但不可以删除已有元素。其中的元素越多，false positive rate(误报率)越大，但是false negative (漏报)是不可能的

### 补救方法

布隆过滤器存在一定的误识别率。常见的补救办法是在建立白名单，存储那些可能被误判的元素。 比如你苦等的offer 可能被系统丢在邮件垃圾箱（白名单）了。

### 使用场景

布隆过滤器的最大的用处就是，能够迅速判断一个元素是否在一个集合中。因此它有如下三个使用场景:

- 网页爬虫对 URL 的去重，避免爬取相同的 URL 地址
- 进行垃圾邮件过滤：**反垃圾邮件**，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）
- 有的黑客为了让服务宕机，他们会构建大量不存在于缓存中的 key 向服务器发起请求，在数据量足够大的情况下，频繁的数据库查询可能导致 DB 挂掉。布隆过滤器很好的解决了**缓存击穿**的问题。


